WWN <- R6::R6Class(
  "WWN",

  private = list(
    K  = NULL,  # number of neighbours
    p  = NULL,  # window size (past periods)
    ts = NULL   # training time series (can be numeric or ts)
  ),

  public = list(

    #' Create a WWN object
    #' @param K The number of neighbours to select
    #' @param p The number of past periods to use (window size)
    initialize = function(K, p) {
      if (!is.numeric(K) || length(K) != 1L || K < 1)
        stop("K must be a positive integer.")
      if (!is.numeric(p) || length(p) != 1L || p < 1)
        stop("p must be a positive integer.")

      private$K <- as.integer(K)
      private$p <- as.integer(p)
    },

    #' Fit the WWN model to training data
    #' @param X A numeric or ts time series to fit the model
    fit = function(X) {
      if (!is.numeric(X))
        stop("X must be a numeric (or ts) vector.")

      if (length(X) <= private$p)
        stop("Time series is too short compared to p (window size).")

      # keep X as is (preserve ts attributes if present)
      private$ts <- X
      invisible(self)
    },

    #' Predict the next values over h periods
    #' @param h The number of periods to predict (forecast horizon)
    #' @return A ts object of length h with the WNN forecast
    predict = function(h) {
      if (is.null(private$ts))
        stop("Model has not been fitted yet. Call fit() first.")

      if (!is.numeric(h) || length(h) != 1L || h < 1)
        stop("h must be a positive integer.")

      h   <- as.integer(h)
      ts_obj <- private$ts
      ts_num <- as.numeric(ts_obj)   # numeric version for computations
      p   <- private$p
      Tlen <- length(ts_num)

      if (Tlen < p + h)
        stop("Time series is too short to forecast h steps with window p.")

      # Build training windows + future vectors
      i_start <- p
      i_end   <- Tlen - h
      N       <- i_end - i_start + 1L

      if (N <= 0)
        stop("Not enough data for training given p and h.")

      X_train <- matrix(NA_real_, nrow = N, ncol = p)
      Y_train <- matrix(NA_real_, nrow = N, ncol = h)

      for (n in seq_len(N)) {
        i <- i_start + n - 1L
        X_train[n, ] <- ts_num[(i - p + 1L):i]
        Y_train[n, ] <- ts_num[(i + 1L):(i + h)]
      }

      # Query window: last p values
      x_query <- ts_num[(Tlen - p + 1L):Tlen]

      # Euclidean distances
      diffs <- X_train - matrix(x_query, nrow = N, ncol = p, byrow = TRUE)
      d2    <- rowSums(diffs^2)
      d     <- sqrt(d2)

      # Select K nearest neighbours
      K_eff <- min(private$K, N)
      ord   <- order(d)
      idx   <- ord[seq_len(K_eff)]
      d_k   <- d[idx]
      Y_k   <- Y_train[idx, , drop = FALSE]

      # Weights alpha_j = 1 / dist_j^2
      eps  <- 1e-8
      wts  <- 1 / (d_k^2 + eps)
      wts  <- wts / sum(wts)

      # Weighted average of neighbours' future vectors
      pred_num <- as.numeric(wts %*% Y_k)

      # Wrap as ts object
      if (inherits(ts_obj, "ts")) {
        tsp_x  <- stats::tsp(ts_obj)
        freq   <- tsp_x[3L]
        # Start right after last observation
        start_pred <- tsp_x[2L] + 1 / freq
        pred_ts <- stats::ts(pred_num, start = start_pred, frequency = freq)
      } else {
        # Generic numeric series: index is 1,2,...; start at Tlen + 1
        pred_ts <- stats::ts(pred_num, start = Tlen + 1L, frequency = 1)
      }

      return(pred_ts)
    }
  )
)
